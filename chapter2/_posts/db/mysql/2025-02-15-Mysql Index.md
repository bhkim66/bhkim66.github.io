# MySQL의 Index

인덱스는 한 테이블당 보통 3~5개가 적당하다

- 정규화나 테이블 목적에 따라 개수는 달라질 수 있다
- 4가지 기준을 사용하여 부합한느 컬럼을 인덱스로 설정하는 것이 좋다

### 카디널리티

- 카디널리티가 높으면 인덱스 설정에 좋은 컬럼이다 (인덱스를 통해 불필요한 데이터의 대부분을 걸너낼 수 있다

### 선택도 **(Selectivity)**

- 선택도가 낮으면  인덱스 설정에 좋은 컬럼이다 (일반적으로 5~10%가 적당하다)
- 선택도가 높다 = 한 컬럼이 갖고 있는 값 하나로 여러 row가 찾아진다
- 선택도가 낮다 = 한 컬럼이 갖고 있는 값 하나로 적은 row가 찾아진다

### 조회 할용도

- 조회 활용도가 높으면 인덱스 설정에 좋은 컬럼이다
- `where`의 대상 컬럼으로 많이 활용되는지 판단한다

### 수정 빈도

- 수정 빈도가 낮으면 인덱스 설정에 좋은 컬럼이다

그 외에

- ORDER BY에 자주 사용되는 컬럼에 사용하기
- JOIN에 자주 사용되는 컬럼 사용하기

### 여러 컬럼으로 인덱스시 조건 누락

[A, B, C] 의 인덱스가 있다고 가정했을 때,

```java
SELECT * FROM user WHERE A = ‘TEST’ AND C = 12
```

- 위 커리처럼 B가 중간에 빠져도 정상적으로 인덱스가  사용 가능하다

```java
SELECT * FROM user WHERE B = ‘TEST’ AND C = 12
```

- 하지만 첫번째 인덱스 조건이 빠지게 되면 인덱스를 사용하지 못하게 된다
- 첫번째 인덱스 조건은 무조건 조회 조건에 포함되어야 한다

### 인덱스 조회시 주의 사항

- `between`, `like`, `<`, `>` 등 범위 조건은 **해당 컬럼은 인덱스를 타지만, 그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않는다**

    ```java
    WHERE A = 10 AND B BETWEEN 5 AND 15 AND C = 20
    ```

    - `A = 10`: 정확히 일치 조건 → **엑세스 조건으로 사용됨**.
    - `B BETWEEN 5 AND 15`: 범위 조건 → **엑세스 조건으로 사용됨**.
    - `C = 20`: 범위 조건 이후이므로 **인덱스를 타지 않고 필터 조건으로 처리됨**
- 반대로 `=`, `in` 은 다음 컬럼도 인덱스를 사용한다
    - `in`은 결국 **`=`를 여러번 실행**시킨 것이기 때문이다
    - 단, `in`은 인자값으로 상수가 포함되면 문제 없지만, **서브쿼리를 넣게되면 성능상 이슈가 발생한다**
    - `in`의 인자로 **서브쿼리가 들어가면 서브쿼리의 외부가 먼저 실행**되고, `in` 은 체크조건으로 실행되기 때문입니다.
- `AND`연산자는 각 조건들이 읽어와야 할 ROW수를 줄이는 역할을 하지만, **`or` 연산자는 비교해야할 ROW가 더 늘어나기 때문에 `full scan` 이 발생할 확률**이 높다
    - `WHERE` 에서 `OR`을 사용할때는 주의가 필요하다
- 인덱스로 사용된 **컬럼값 그대로 사용해야만 인덱스가 사용된다**
    - 인덱스는 가공된 데이터를 저장하고 있지 않다
    - `where salary * 10 > 150000`는 인덱스를 못타지만, `where salary > 150000 / 10` 은 인덱스를 사용한다
- null 값의 경우 **is null 조건으로 인덱스 레인지 스캔 가능**
- Like 문장에서 문자열 앞에 `%`가 사용되면 정렬 순서를 사용할 수 없음으로 테이블 `full scan`이 이루어진다

```java
select * from table where name like '%word';
```

- **Optimizer 의 선택**

```sql
select * from table where name ='word' and id ='elky';
```

- 인덱스가 name 과  id로 2개가 있을 경우 id나 name 인덱스 중 하나가 선택될 수도 있고, 둘 다 선택될 수도 있다.
- 어떤 방식으로 선택하는냐가 속도에 중요할 수도 있다. 즉 실행 계획을 추적해서 원하는 결과가 나오도록 관리가 필요하다.

## 인덱스와 Sort

인덱스는 항상 **정렬되어 있는 상태를 유지하기 때문에** 인덱스에 정렬을 위한 컬럼을 추가하여 **Sort 작업을 거칠 필요가 없다**

[a, b, c] 인덱스가 있다는 가정하에

```java
ORDER BY (a, b, c); // 정렬 컬럼과 인덱스 컬럼이 일치
ORDER BY (a, b); // 정렬 컬럼이 인덱스의 맨 앞 컬럼을 포함한 부분집합이면서 순서가 동일
```

아래는 정렬에 사용할 수 없는 경우이다

```java
ORDER BY b, c // 인덱스의 앞 쪽 컬럼 누락
ORDER BY a, c // 중간에 사용된 b가 누락
ORDER BY a, c, b // 순서 다름
ORDER BY a, b, c, d // 인덱스에 포함되지 않은 컬럼 존재
ORDER BY a, b desc, c // 순서가 일치하지만 b 컬럼의 정렬 방식이 달라 불가
```

- 다행히 모든 컬럼이 `ORDER BY`에만 명시될 필요가 없다
- `ORDER BY`에 포함되지 않더라도  인덱스 순서를 지키는 한 `WHERE` 조건에 컬럼이 명시되어도 정렬에 인덱스를 사용할 수 있다

```java
// 사용 가능
WHERE a = ? ORDER BY b, c;
WHERE a = ? ORDER BY b;
WHERE a = ? and b = ? ORDER BY c;
WHERE a = ? and b = ? and c = ?;
```

`WHERE` 절이 동등비교가 아닐 때에도 정렬 시 인덱스를 사용할 수 없으므로, 그럴 땐 차라리 `ORDER BY` 조건에 명시적으로 해당 컬럼을 넣어주는게 좋다

```sql
// 동등비교가 아니므로 인덱스 정렬 불가, Using temporary; Using filesort 발생
WHERE a like 'something%'
ORDER BY b, c;

// 인덱스 정렬 가능
WHERE a like 'something%'
ORDER BY a, b, c;
```

## Using filesort

`Using filesort`는 쿼리에서 첫 번째로 조회하는 테이블에 대해서만 정렬이 필요한 경우이다

- 일반적으론 단일 테이블에 대해 실행한 쿼리가 정렬 시 인덱스를 사용하지 못하는 경우 발생한다.

```java
ORDER BY b, c // 인덱스의 앞 쪽 컬럼 누락
ORDER BY a, c // 중간에 사용된 b가 누락
ORDER BY a, c, b // 순서 다름
ORDER BY a, b, c, d // 인덱스에 포함되지 않은 컬럼 존재
ORDER BY a, b desc, c // 순서가 일치하지만 b 컬럼의 정렬 방식이 달라 불가
```

`filesort`가 필요한 상황이 발생하면, MySQL에선 내부적으로 테이블을 `Sort Buffer`에 옮겨 정렬하는 작업을 거친다.

- **정렬 컬럼이 인덱스에 없는 경우**
    - 전체 비용과 실행 시간이 대부분 `Sort` 과정에서 발생한다. 테이블의 전체를 스캔한다
- **정렬 컬럼이 인덱스에 없는 경우**
    - `Sort` 과정이 사라지고 limit 키워드가 존재 할 경우 `limit` 개수만큼 실행된다

![image.png](/assets/img/chapter2/mysql/mysql_2_1.png)

### **Using temporary**

`Using temporary`는 정렬 작업을 위해 임시 테이블이 필요한 경우를 말한다

인덱스를 통해 정렬을 수행할 수 없거나, `filesort`만으로 정렬을 완료할 수 없는 경우 임시 테이블을 생성해 그곳에 조회된 데이터들을 모두 밀어 넣고 정렬하는 작업을 거친다

- **조인 등을 통해 테이블 여러 개가 혼합되는 상황**에서 아무래도 발생할 가능성이 높다

![image.png](/assets/img/chapter2/mysql/mysql_2_2.png)

임시테이블을 사용하는 경우, 조회된 데이터 조합을 모두 밀어 넣어야 함으로 당연히 인덱스나 `filesort`보다 성능이 좋지 못하다.

조회되는 데이터가 많으면 많을수록 속도는 더 느려질 것이다.

### 페이징의 중요성

ORDER BY 조건절의 컬럼에 인덱스를 생성했을 때, 정렬 연산을 생락한다는 것을 확인했다

또한 부분 범위 처리로 인한 성능 개선되었다. 10개의 레코드를 얻기 위해 `Table full scan`을 하는 것과 인덱스 트리를 탐색해서 10개의 레코드만 탐색하는 것은 당연히 차이가 난다

출처 - Real MySQL 8.0
# 인덱스 기본
## 인덱스 구조 및 탐색

데이터베이스 테이블에서 데이터를 찾는 방법은 두가지 방법이 있다

- 테이블 전체를 스캔한다
- 인덱스를 이용한다

**인덱스 튜닝의 두 가지 핵심요소**

인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.

- 온라인 트랜잭션 처리(Online Transcation Processing, `OLTP`) 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다

**핵심요소**

1. 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
    1. 인덱스 스캔 효율화 튜닝
2. 테이블 엑세스 횟수를 줄이는 것
    1. 인덱스 스캔 후 테이블 레코드를 엑세스할 때 랜덤 I/O 방식을 사용하므로 이를 `랜덤 액세스 최소화 튜닝` 이라고 한다
    2. 랜덤 엑세스를 줄이는 것이 성능이 메치는 영향이 크다

**SQL 튜닝은 랜덤 I/O와의 전쟁**

데이버베이스 성능이 느린 이유는 디스크 I/O 때문이다. 인덱스를 많이 사용하는 OLTP 시스템이라면 `디스크 I/O` 중에서도 `랜덤 I/O`가 중요하다

조인 메소드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터를 조인할 때 느린 이유도 `I/O` 때문이다

그래서 `소트머지 조인`과 `해시 조인`이 개발됐으므로 이들 조인 메소드도 결국 느린 `랜덤 I/O`를 극복하기 위해서 개발된 기능이다

### 인덱스 구조

데이터베이스에서 **인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다**

반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. `범위 스캔`이 가능하다. 범위 스캔이 가능한 이유는 인덱스는 정렬돼 있기 때문이다

![image.png](/assets/img/chapter2/database/sql_tuning/sql_tuning_2_1.png)

루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키 값은 하위 블록에 저장된 키 값의 범위를 나타낸다

- 자식 노드중 가장 왼쪽 끝에 위치한 블록을 `LMC`라 한다
- 리프 블록에 저장된 각 레코드는 키 값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다
    - 인덱스 키 값이 같으면 `ROWID` 순으로 정렬된다
    - 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 `ROWID`를 얻기 위해서이다

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다

- 수직적 탐색 : 인덱스 **스캔 시작지점**을 찾는 과정
- 수평적 탐색 : **데이터를 찾는 과정**

### 인덱스 수직적 탐색

정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, 인덱스 스캔 시작지점을 찾는 과정이다

인덱스 수직적 탐색은 루트 블록에서부터 시작한다. 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 `주소값`을 갖는다

수직적 탐색 과정에 찾고자 하는 값보다 **크거나 같은 값을 만나면**, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다

### 인덱스 수평적 탐색

수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 **리프 블록을 수평적으로 스캔한다.** 인덱스에서 **본격적으로 데이터를 찾는 과정**이다

인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다 = `Double Linked List` 형태

수평적 탐색의 이유

- 조건절을 만족하는 데이터를 모두 찾기 위해서
- `ROWID`를 얻기 위해서

### 결합 인덱스 구조와 탐색

인덱스에 대한 오해가 바로 결합 인덱스를 구성 시 선택도가 낮은 컬럼을 앞에 두고 결합 인덱스를 생성해야 검사 횟수를 줄여 성능에 유리하다고 알려져 있다.

- 이는 엑셀과 같은 평면 구조라면 맞는 말이다
- 하지만 DBMS는 B*Tree 인덱스는 다단계 구조이며, 루트에서 브랜치를 거쳐 리프 블록까지 탐색하기 때문에 **어느 컬럼에 앞에 두둔 일량에는 차이가 없다**

## 인덱스 기본 사용법

### 인덱스를 사용하는 것

인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용 할 수 있다 = `Index Range Scan`

인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, **스캔 시작점을 찾을 수 없고 멈출 수 없어 리프 블록 전체를 스캔**해야만 한다. 즉, 일부가 아닌 전체를 스캔하는 `Index Full Scan` 방식으로 작동한다

### 인덱스를 Range Scan 할 수 없는 이유

인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 `인덱스 스캔 시작점을 찾을 수 없기 때문이다`

Index Range Scan은 인덱스에서 일정 번위를 스캔한다는 뜻이다. 일정 범위를 스캔하려면 `시작지점`과 `끝지점`이 있어야 한다

- 인덱스에는 가공되지 않은 값이 저장돼 있는데, 가공된 값을 기준으로 검색하려면 어디서 스캔을 시작해야 할까
- 스캔 시작점을 찾을 수 없다. 스캔 끝 지점도 찾을 수 없다. **어디서 스캔을 멈춰야 하는지를 모른다**
- LIKE로 중간 값을 검색 할 때도 발생한다
    - ‘대한’으로 시작하는 값은 특정 구간에 모여 있으므로 Range Scan이 가능하지만, ‘대한’을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 Range Scan이 불가능하다
    - where 업체명 like ‘%대한%’
- OR 조건으로 검색하는 경우에도 수직적 탐색을 통해 전화번호나, 고객명이 일치하는 어느 한 시작지점을 바로 찾을 수 없다.
    - where (전화번호 = :tel_no OR 고객명 = :cust_nm)
- IN절의 경우 OR절을 표현하는 다른 방식일 뿐이다.
    - 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 `IN-List Iterator` 방식을 사용한다.
    - IN-List 개수만큼 `Index Range Scan`을 반복하는 것이다

결국 인덱스를 정상적으로 사용한다. 라는 표현은 **리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미**한다

### 인덱스 사용 조건

인덱스를 [소속팀 + 사원명 + 연령] 순으로 구성했을 때 아래 조건절에 대해 인덱스를 정삭적으로 Range Scan 할 수 있을까?

```sql
select 사원번호, 소속팀
from 사원
where 사원명 = '홍길동'
```

인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 사실이다 (가공하지 않은 채로)

**인덱스 잘 타니까 튜닝 끝?**

인덱스를 잘 타면 성능이 문제 없다고 생각할 수 있다.

[주문일자 + 상품번호] 순으로 인덱스를 구성하고 아래 조건절을 확인해보자.

- **인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다**

```sql
SELECT * 
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND 상품번호 LIKE '%PING%'

SELECT * 
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND SUBSTR(상품번호, 1, 4) = 'PING'
```

위 SQL에서 상품번호는 스캔 범위를 줄이는데 전혀 끝 역할을 하지 못한다.

- 첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다

### 인덱스를 이용한 소트 연산 생략

인덱스 컬럼을 가공해도 인덱스를 사용할 순 있지만, 흩어져 있어 Range Scan이 불가능하거나 비효율이 발생할 수 있다

그런데 인덱스는 정렬이 되어 있는 상태로 유지하기 때문에 **소트 연산 생략 효과를 부수적으로 얻게 된다**

옵티마이저는 SQL에 `ORDER BY`가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 인덱스 정렬 순으로 정렬되기 때문이다

- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, 아래와 같이 SORT ORDER BY 연산 단계가 추가된다

```sql
Execution Plan
------------------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=86 Card=81 Bytes=5K)
1  0    SORT (ORDER BY) (Cost=86 Card=81 Bytes=5K)
2  1      TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85 ...)
3  2        INDEX (RANGE SCAN) OF '상태번경이력_PK' (INDEX (UNIQE)) (Cost=3 ...)
```

### ORDER BY 절에서 컬럼 가공

`ORDER BY` 또는 `SELECT-LIST`에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 있다

[장비번호 + 변경일자 + 변경순번] 순으로 인덱스를 구성한다면 아래 SQL도 정렬을 생략할 수 있다

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집학적, 선언적 질의 언어

SQL은 ‘**Structured Query Language**’의 줄임말이다. 말 그대로 구조적 질의 언어라는 뜻을 가지고 있다

- `구조적`이고 `집합적`이고 `선언적`인 질의 언어이다

### 1.1.2 SQL 최적화

1. SQL 파싱

사용자로부터 SQL을 전달받으면 가장 먼저 `SQL 파서`가 파싱을 진행한다

- 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인, 예를 들어, 사용하 수 없는 키워드를 사용했거나 순서가 바르지 않거나 누락된 키워드가 있는지 확인
- Semantic 체크 : 의미상 오류가 없는지 확인. 예를 들어, 존재하지 않는 테이블 또는 컬럼을 사용했는지, 사용한 오브젝트에 대한 권한이 있는지 확인
1. SQL 최적화

그다음 단계가 SQL 최적화이고, `옵티마이저`가 그 역할을 맡는다. 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕을 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택한다. **데이터베이스 성능을 결정하는 가장 핵심적인 엔진**이다

1. 로우 소스 생성

실제 실행 가능한 코드 또는 프러시저 형태로 포맷팅하는 단계. 로우 소스 생성기가 그 역할을 맡는다

### 1.1.3 SQL 옵티마이저

사용자가 가장 **효율적으로 작업을 수행할 수 있게 하는 최적의 데이터 엑세스 경로를 선택해 주는 DBMS의 핵심 엔진**이다

1. 사용자로부터 전달 받은 쿼리를 통해 후보군이 될만한 실행계획들을 찾아낸다
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다
3. 최저 비용을 나타내는 실행계획을 선택한다

### 1.1.4 실행계획과 비용

DBMS에서 ‘SQL 실행경로 미리보기’ 기능이 `실행계획`이다

이를 통해 테이블을 스캔하는지 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지를 확인할 수 있고, 예상과 다른 방식으로 처리된다면 실행경로를 변경할 수 있다

### 1.1.5 옵티마이저 힌트

SQL 옵티마이저가 대부분 좋은 선택을 하지만 완벽하진 않다. 이를 위해 옵티마이저 힌트를 사용하면 **데이터 엑세스 경로를 바꿀 수 있다**

**주의사항**

- 힌트와 힌트 사이에 ‘,’ 콤마를 사용할 수 없다

    ```sql
    /*+ INDEX(C), FULL(D) */ → 불가능
    ```

- 테이블을 지정할 때 아래와 같이 스키마명까지 명시하면 안 된다

    ```sql
    SELECT /*+ FULL(SCOTT.EMP) */ -> 무효
    	FROM EMP
    ```

- FROM 절 테이블명 옆에 ALIAS를 지정했다면, 힌트에도 반드시 ALIAS를 사용해야 한다

    ```sql
    SELECT /*+ FULL(EMP) */
    	FROM EMP E
    ```

- 옵티마이저의 작은 실수로 큰 손실을 일으키는 시스템이라면 힌트를 사용해도 좋다. 하지만 **빈틈없이 기술해야 한다**

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 VS 하드 파싱

SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 `라이브러리 캐시`라고 한다. 라이브러리 캐시는 `SGA`(System Global Area) 구성요소이다. SGA는 서버 프로세스와 백그라운드 프로세스가 공통을 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다

![image.png](/assets/img/chapter2/database/sql_tuning/sql_tuning_1_1.png)

- 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다.
- 캐시에서 찾으면 곧바로 실행 단계로 넘어가지만, 찾지 못하면 최적화 단계를 거친다
- SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 `소프트 파싱`이라고 하고, 찾는 데 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 `하드 파싱`이라고 한다

![image.png](assets/img/chapter2/database/sql_tuning/sql_tuning_1_2.png)

옵티마이저가 SQL을 최적화할 때 데이터베이스 사용자들이 보통 생각하는 것보다 훨씬 많은 일을 수행한다

SQL 옵티마이저는 순식간에 엄청나게 많은 연산을 한다. 그 과정에 옵티마이저가 사용하는 정보는 다음과 같다

- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

하나의 쿼리를 수행하는 데 있어 후보군이 될만한 무수히 많은 실행경로를 도출하고, 짧은 순간에 딕셔너리와 통계정보를 읽어 각각에 대한 효율성을 판단하는 **과정은 결코 가벼울 수 없다**. **데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되면 반면**, 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나다

### 1.2.2 바인드 변수의 중요성

**이름없는 SQL 문제**

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다

**반면 SQL은 따로 이름이 없다. 전체 SQL문이 이름을 대신한다**

딕셔너리에 저장하지도 않는다. 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 `라이브러리 캐시`에 적재함으로써 **여러 사용자가 공유하면서 재사용**한다. 캐시 공간이 부족하면 버리졌다가 다음에 다시 실행할 때 **똑같은 최적화 과정을 거쳐 캐시에 적재**한다

**공유 가능 SQL**

라이브버리 캐시에서 SQL을 찾기 위해 사용하는 키 값이 ‘SQL 문 그자체’ 이다

DBMS에 발생하는 부하는 대개 **과도한 I/O가 원인**인데 동시 다발적으로 발생하는 SQL 하드파싱 또한 원인 중 하나이다

`바인드 변수`를 통해 변수값만 파라미터 값으로 받고 SQL문은 공유함으로서 하드파싱은 최초 한 번만 일어나고, 캐싱된 SQL을 사용하여 최적화를 이뤄낸다
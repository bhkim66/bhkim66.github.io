# SQL 처리 과정과 I/O -2
## 1.3 데이터 저장 구조 및 I/O 메커니즘

I/O 튜닝이 곧 SQL 튜닝이라고 해도 과언이 아니다. SQL 튜닝 원리를 제대로 이해하려면 I/O에 대한 이해가 중요할 수 밖에 없다

### 1.3.1 SQL이 느린 이유

**SQL이 느린 이유는 대부분 I/O 때문이다.**

I/O란? 프로세스로 부터 들어오고 나가는 데이터의 흐름이라고 할 수 있다

프로세스는 실행 중이 프로그램이며, `생성` 이후 `종료` 전까지 `준비`와 `실행`과 `대기` 상태를 반복한다. 실행 중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태로 전환했다가 다시 실행 상태로 전환한다. 특정 순간에는 하나의 프로세스만 cpu를 사용할 수 있기 때문에 이런 메커니즘이 필요하다.

전반적으로 I/O 튜닝이 안 된 시스템이라면, **수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디크스 경합이 심해지고 그만큼 대기 시간도 늘어난다**.

### 1.3.2 데이터베이스 저장 구조

데이터를 저장하려면 먼저 `테이블스페이스`를 생성해야 한다. `테이블스페이스`는 세그먼트를 담는 콘테이너로서, 여러 개의 데이터파일로 구성된다

- 테이블스페이스는 여러개의 `세그먼트`로 구성되어 있다.
  - 세그먼트는 `테이블`, `인덱스`처럼 데이터 저장공간이 필요한 오브젝트다
  - 세그먼트는 여러 `익스텐트`로 구성된다
  - 테이블도 하나의 `세그먼트`이며, 인덱스도 하나의 `세그먼트`다
- `익스텐트`는 공간을 확장하는 단위이다
  - 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다
  - 익스텐트는 연속된 블록들의 집합이기도 하다
  - `익스텐트` 단위로 공간을 확장하지만, 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이다.
    - 하나의 블록은 하나의 테이블이 독점한다
    - 즉 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다

세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는데, **세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있**다. **파일 경합을 줄이기 위해** 서로 다른 데이터파일에 위치할 가능성이 더 높다.

**DBA**

> 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값이다. 인덱스를 이용해 테이블 레크드를 읽을 때는 인덱스 `ROWID`를 이용해야한다. `ROWID`는 DBA + 로우 번호(블록 내 순번)로 구성된다
>
- 블록 : 데이터를 읽고 쓰는 단위
- 익스텐트 : 공간을 확장하는 단위. 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트
- 테이블스페이스 : 세그먼트를 담는 콘테이너
- 데이터파일: 디스크 상의 물리적인 OS 파일

### 1.3.3 블록 단위 I/O

익스텐트는 공간을 확장하는 단위이다. 블록이 바로 DBMS가 데이터를 읽고 쓰는 단위다. 데이터 I/O **단위가 블록**이므로 특정 레코드 하나를 읽고 싶어도 해당 **블록을 통째로 읽는다**. 테이블 뿐만 아니라 인덱스 또한 블록 단위로 통째로 읽고 쓴다.

### 1.3.4 시퀀셜 엑세스 VS 랜덤 엑세스

테이블 또는 인덱스 블록을 엑세스하는 방식으로는 `시퀀셜 엑세스`와 `랜덤 엑세스`, 두 가지가 있다

- 시퀀셜 엑세스는 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다
- 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 `논리적으로 서로 연결돼 있다`
- 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 엑세스다

테이블 블록 간에는 서로 논리적인 연결고리를 갖고 있지 않다. 어떻게 읽어 드릴까?

- `Full Table Scan`은 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에서 연속해서 저장된 블록을 순서대로 읽는다
- 랜덤 엑세스는 논리적, 물리적인 순서를 따르지 않고, 레코드를 하나를 읽기 위해 한 블록씩 접그하는 방식이다

### 1.3.5 논리적 I/O, 물리적 I/O

자주 읽는 블록은 매먼 디스크에서 읽는 것은 매우 비효율적이다.

`라이브 캐시`가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 `코드 캐시`라고 한다면, `DB 버퍼 캐시`는 `데이터 캐시`라고 할 수 있다

디스크에서 어렵게 읽는 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O cALL을 줄이는 데 목적이 있다
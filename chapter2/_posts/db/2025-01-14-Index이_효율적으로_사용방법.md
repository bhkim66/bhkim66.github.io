# 인덱스 효율적으로 사용 방법

단일 컬럼, 멀티 컬럼에 대해 인덱스를 생성한 경우 인덱스 하나에 대한 `인덱스 테이블`이 생기게 된다

이런 상황에서 만일 해당 테이블에 로우가 추가되거나 삭제되면 테이블에 설정되어 있는 각 인덱스에 해당 데이터 로우가 추가, 삭제 되며, 이때 각 인덱스의 기준에 맞춰 **정렬작업**이 필요하다

인덱스의 수가 많을 경우 존재하는 만큼의 `인덱스 테이블` 데이터가 추가, 삭제 되면서 **트리 구조 재배치 작업이** 발생한다

- `DML`에 대한 성능저하(`TPS` 저하, TPS = 1 초당 처리할 수 있는 트랜잭션)
- 데이터베이스 사이즈 증가(인덱스가 차지하는 공간으로 인한 디스크 공간 낭비)
- 필요하지 않은 인덱스로 인해 디스크 공간을 낭비하고, 운영비용이 증가한다
    - 따라서 제대로 된 인덱스 설계가 중요하다

## 인덱스 선택 중요 기준

- 가장 정상적이고 일반적인 방식은 Index Range Scan이다
- 인덱스 **선두 컬럼을 조건절에 반드시 사용해야 한다**. 따라서 인덱스를 구성할 때, **조건절에 항상 사용하거나 자주 사용하는 컬럼을 인덱스로 선정**해야 한다
- 그렇게 선정한 컬럼 중 `=` 조건을 자주 조회하는 컬럼을 앞 쪽에 두어야 한다

### 어떤 컬럼에 INDEX를 설정하는 것이 좋은가?

- **수정 빈도:** UPDATE, DLELTE가 자주 발생하지 않는 컬럼
- **활용도:** `join`과 `where`, `order by`에 자주 사용하는 컬럼
- **중복도**: 데이터의 중복도가 낮은 컬럼 (`카디널리티`가 높음 = 유니크 함이 높다)

### 인덱스 생성 순서

1. `==`이나 `equal`같이 동등비교 연산 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬에 쓰는 필드가 있다면 가 다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드 (>, <, between)등 많은 값을 출력하는 쿼리에 설정
4. `카디널리티`가 높은 순서대로 설정

## 인덱스 효율 늘리는 법

### 엑세스 조건과 필터 조건

인덱스의 엑세스 조건과 필터 조건은 데이터베이스에서 인덱스가 사용될 때, 쿼리의 효율성을 결정하는 중요한 요소들이다.

**엑세스 조건**

- 인덱스 스캔 범위를 결정하는 조건절
- 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 `리프 블록`을 스캔하다가 어디서 멈출지를 결정한다
    - 주로 WHERE 절에서 인덱스의 키 컬럼에 대한 동등 조건(=), 범위 조건(>, <, BETWEEN) 등을 포함한다
    - `INDEX RANGE SCAN`또는 INDEX UNIQUE SCAN에서 사용된다
    - ex) SELECT * FROM user WHERE user_id = 10

**필터 조건**

- 인덱스 스캔 후에 데이터가 추가적으로 필터링되는 조건이다
- 필터 조건은 인덱스가 적용되지 않으며, **데이터 블록을 스캔한 후** 행 수준에서 필터링이 이뤄진다
    - ex) SELECT * FROM user WHERE user_id = 10 AND age > 10
    - 뒤쪽 컬럼이 인덱스 효과를 보지 못하고 필터링 부분 된다

![image.png](/assets/img/chapter2/database/dababase_1_1.png)

- 인덱스 키에 맞게 엑세스 조건을 최대한 활용하여, 데이터를 빠르게 찾고 불필요한 테이블 스캔을 줄여야 한다
    - **자주 쿼리되는 열을 인덱스 키로 설정**하고, **WHERE 조건에 동등 또는 범위 조건을 사용하면 엑세스 조건을 효과적으로 활용**할 수 있다
- 필터 조건을 줄이기 위해 추가 인덱스를 설정하거나, 필요한 열을 인덱스 키에 포함시키는 것도 성능을 최적화 한다
    - 필터 조건이 자주 사용되면 해당 조건에 맞는 인덱스를 새로 생성하거나, **다중 열 인덱스**를 사용하는 것도 좋다

### BETWEEN을 IN-LIST로 바꿔주면 큰 효과를 얻을 수 있다

```java
SELECT *
FROM 상품
WHERE 상품코드 in ('1', '2', '3')
AND 상품타입 = 'A'
```

- BETWEEN 조건을 IN-List로 바꾸었을 때, 인덱스 수직적 탐색이 세 번 발생한다
    - **INLIST ITERATOR 실행**
- 하지만 IN 절 항목 개수가 많지 않아야 한다. 항목 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 커질 수 있다. 특히 루트에서 브랜치 블록까지 Depth가 깊을 때 더 그렇다
- IN절은 선택되는 레코들이 서로 멀리 떨어져 있을 때만 유용하다
- IN절과 Range 조건(Between 이나 Like 조건)을 구분하는 기준은 연속선 조건이다. 연속적인 데이터는 RANGE 조건을 사용해야 한다
- IN절은 list 개수만큼 반복처리 되므로 쓸모 없는 부하가 증가한다. 하지만 Range(Between 이나 Like 조건)은 그러한 반복처리와 비효율이 없다

### IN은 = 인가?

```sql
SELECT *
FROM 상품
WHERE 고객번호 = 101
AND 상품ID IN ('1', '2', '3')
```

1. 인덱스 [`상품ID`+ `고객번호`] 일 경우,
    - 같은 `고객번호`가 상품 ID에 따라 흩어진 상태 (연속되지 않는 리프블록에 저장) → `IN-List Iterator` 방식으로 푸는 것이 효과적
    - 이 경우에는 IN 조건이 `=` 조건이 되었다. 수직적 탐색이 3번 일어난다.

![image.png](/assets/img/chapter2/database/dababase_1_2.png)

- 고객 번호가 흩어져 있는 상황 → IN-List Iterator 사용
1. 인덱스 [`고객번호` + `상품ID`] 일 경우,
    - 상품ID 순으로 정렬된 상태로 같은 리프 블록에 저장, 상품ID 조건절은 필터로 처리한다.
    - 고객번호만 액세스 조건이므로 한 블록만 스캔한다

![image.png](/assets/img/chapter2/database/dababase_1_3.png)

**즉, IN 조건이 `=`이기 위해서는 IN-List Iterator 방식으로 풀려야 한다. 그렇지 않으면 IN 조건은 필터 조건이다.**

### BETWEEN과 LIKE 스캔 범위

```java
(1) SELECT * FROM 월별고객판매집계 WHERE 판매월 LIKE '2024%'

(2) SELECT * FROM 월별고객판매집계 WHERE 판매월 BETWEEN '202401' and '202412'
```

- BETWEEN과 LIKE 모두 범위검색 조건이지만, **LIKE 보다는 BETWEEN을 사용하는 것이 더 낫다.** → (2)이 더 정확한 표현

### Sort 연산을 생략하기 위한 커럼

- 인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 sort 연산을 생략할 수 있다. 조건절에 사용하지 않는 컬럼이라도 sort 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다
- I/O를 최소화하면서 sort 연산을 생략하기 위해서는
    - `=` 연산자로 사용한 조건절 컬럼 선정
    - ORDER BY 절에 기술한 컬럼 추가
    - `=` 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
- 주의할 점으로는, `=` 조건절 컬럼은 ORDER BY절에 없더라도 인덱스 구성에 포함시킬 수 있으며 위치는 앞뒤 중간 어디에 두어도 상관없지만, `=`가 아닌 조건절 컬럼은 반드시 ORDER BY 컬럼보다 뒤에 두어야 한다
- ex) [`출고일자` + `상품카테고리ID` + `등록자ID`] 순과 같이 `=` 조건절 컬럼인 `상품카테고리ID`은 아무 위치나  인덱스를 구성해도 소트연산은 생략할 수 있지만, 조건절 컬럼인 `가격` 컬럼을 인덱스에 포함시키기 위해서는 [`출고일자` + `등록자ID` + `가격`] 과 같이 ORDER BY 컬럼보다 뒤쪽에 뒤어야 한다.

```java
SELECT *
FROM 상품
WHERE 상품카테고리ID = :category_id
AND 출고일자 BETWEEN :sdt AND :edt
AND 가격 >= 1000
AND 상품코드 IN ('1', '2', '3')
ORDER BY 출고일자, 등록자ID
```
# JPA

- `JPA`는 *데이터베이스 기술이라기 보다* 애플리케이션의 데이터를 `객체지향` 관점으로 바라보고 다룰 수 있게 해주는 `객체지향` 기술이다
- 객체 모델과 `관계형 데이터베이스` 모델은 지향하는 페러다임이 서로 다르다. `JPA`는 이를 극복하고자 정교한 객체 모델링을 유지하게 도와준다
- `JPA`는 자바 ORM 기술에 대한 API 표준 명세이다

### JPA 사용 이유

- 생산성 : 지루하고 반복적인 CRUD용 SQL문을 작성하지 않아도 된다. 또는 DDL문을 **자동으로 생성해주는 기능**도 있다
- 유지보수 : SQL 의존적인 개발은 `엔티티`에 필드를 하나만 추가해도 SQL 결과를 매핑하기 위한 `JDBC API` 및 `SQL` 문들을 다 수정해야 했다. 반면에 `JPA`를 사용하면 이런 과정을 대신 처리해주므로 수정해야 할 코드가 줄어든다
- 성능 : `JPA`를 사용시 조회한 객체는 **재사용**하여 여러번 통신을 방지한다
    - 패러다임 불일치 해결 : `JPA`는 **상속, 연관관계, 객체 그래프 탐색, 비교하기**와 같은 패러다임 불일치 문제를 해결해준다
- 데이터 접근 추상화와 벤더 독립성 : 애플리케이션은 처음 선택한 데이터베이스 기술에 *종속되고 다른 데이터 베이스 변경하기는 매우 어렵다.* `JPA` 는 애플리케이션과 데이터베이스 사이에 `추상화`된 데이터 접근 계층을 제공하여 특정 데이터베이스 **기술에 종속**되지 않도록 한다

### MYBATIS VS JPA

- `마이바티스`나 `스프링 JdbcTemplate` 을 보통 SQL 매퍼라 한다. 이것은 이름 그래로 `객체`와 `SQL`을 매핑한다. 개발자는 `SQL`를 직접 작성해야 할 뿐만 아니라 `SQL`에 의존하는 개발을 해야 한다. 이는 `객체지향` 개발의 의의에 벗어나게 된다.

### ORM(Object-Relational Mapping)

- `객체`와 `관계형 데이터베이스`를 매핑한다는 뜻으로 애플리케이션과 데이터베이스 연결 시 `SQL`언어가 아닌 어**플리케이션 개발언어**로 데이터베이스를 접근할 수 있게 해준다
- ORM 프레임워크는 `객체`와 `테이블`을 매핑해서 **패러다임 불일치** 문제를 개발자 대신 해결해준다
- 자바 진영에서 대표적으로 사용하는 ORM 프레임워크에는 `하이버네이트`가 대부분의 패러다임 불일치 문제를 해결한다

### 동일성 VS 동등성

- **동일성** : == 비교로 객체 인스턴스의 `주소` 값을 비교한다
- **동등성** : equals() 메소드를 사용해서 **객체 내부**의 값을 비교한다
- `JPA`는 **같은 트랜잭션**일 때 같은 객체가 조회되는 것을 **보장**한다 ****

### JPA 매핑

- **@ENTITY** : 해당 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @ENTITY가 사용된 클래스를 **엔티티 클래스**라 한다
    - 기본 생성자는 필수 : JPA는 데이터베이스에 데이터를 조회하고 엔티티 객체를 생성할 때 **리플렉션** 기술을 사용하기 때문이다
        - 리플렉션 : 클래스의 정보등을 몰라도 이름으로 클래스의 정보에 접근할 수 있게 해주는 자바 API이다
        - 리플렉션은 기본 생성자 필수이다
    - final 클래스, enum, interface, inner 클래스에는 사용불가
    - 저장할 필드에 final을 사용할 수 없다
- **@Table** : 엔티티 클래스에 매핑할 **테이블 정보를 알려준다**. `name` 속성을 사용하여 엔티티를 테이블에 매핑한다. 생략시 **클래스 이름으로 매핑**한다
- **@Id** : 엔티티 클래스의 필드를 테이블의 `기본 키`에 매핑한다. 이 필드를 `식별자 필드`라 한다
- **@Column** : 필드를 컬럼에 매핑한다. name 속성을 이용하여 필드를 테이블 컬럼과 매핑한다
    - `nullable` 속성 값을 false로 지정시 not null 제약조건 추가 할 수 있다
- **@Enumerated :** 자바의 `enum` 타입을 매핑할 때 사용한다.
    - EnumType.ORDINAL : enum **순서**를 데이터베이스에 저장
    - EnumType.STRING : enum **이름**을 데이터베이스에 저장
- **@Temporal** : 날짜 타입을 매핑할 때 사용한다
    - TemporalType.DATE : 날짜, 데이터베이스 date 타입에 매핑
    - TemporalType.TIME : 시간, 데이터베이스 time 타입과 매핑
    - TemporalType.DATESTAMP : 날짜와 시간, 데이터베이스 timestamp 타입과 매핑

### 기본 키 매핑

- **IDENTITY** 전략 : 기본 키 생성을 데이터베이스에 위임하는 전략이다. Mysql처럼 `AUTO_INCREMENT`로 기본키 생성되는 경우 `@GeneratedValue` 어노테이션을 사용하고 식별자 생성 전략을 선택해야한다. ex) @GeneratedValue(strategy = GenerationType.INDENTITY)
    - `IDENTITY 식별자 생성`은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 `persist()` 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 즉 쓰기 지연이 동작하지 않는다
- **SEQUENCE** 전략 : 사용할 데이터베이스 시퀀스를 매핑후 사용한다. ex) @GeneratedValue(strategy = GenerationType.SEQUENCE), generator = “시퀀스명”)
    - `SEQUENCE` 전략은 persist()를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 **식별자를 조회**한다. 그리고 조회한 식별자를 엔티티에 **할당한 후에 엔티티를 영속성 컨텍스트에 저장**한다. 트랜잭션 커밋 후 **플러시가 일어나면** 엔티티를 **데이터베이스에 저장**한다.
- **AUTO 전략** : 데이터베이스 방언에 따라 **자동으로 선택**한다. @GeneratedValue.strategy 기본값은 AUTO 이므로 생락후 사용 가능하다. ex)  @GeneratedValue(strategy = GenerationType.AUTO) → @GeneratedValue
- 기본키는 `자연 키`보다 `대리 키`를 **권장**한다
    - 자연키는 값이 변강할 수도 있고 비지니스의 규칙은 생각보다 **쉽게 변하므로** 위험할 수 있다

### 엔티티 매니저 팩토리(EntityManagerFactory)

- persistence.xml 설정 정보를 바탕으로 `Persistence` 클래스를 사용하여 팩토리를 생성한다
- **엔티티 매니저 팩토리**는 생산 비용이 아주 크기 때문에 **딱 한 번만 생성**하고 애플리케이션 전체에서 **공유해서 사용**해야 한다

### 엔티티 매니저(EntityManager)

- `엔티티 매니저 팩토리`에서 `엔티티 매니저`를 생성한다. `JPA`의 대부분 기능을 엔티티 매니저가 제공한다
- 엔티티 매니저는 내부에 `데이터소스`를 유지하면서 데이터베이스와 통신한다
- 개발자는 엔티티 매니저를 **가상의 데이터베이스**로 생각할 수 있다
- 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 *스레드간에 공유하거나 재사용하면 안된다.* (엔티티 매니저 팩토리는 스레드가 동시에 접근해도 안전하다)
- 엔티티 매니저는 데이터베이스 **연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다**

### 트랜잭션

- JPA를 사용하면 **항상 트랜잭션 안에서 데이터를 변경해야 한다.** 트랜잭션 없이 데이터를 변경시 예외가 발생한다

## 영속성 컨텍스트

- JPA에서 객체를 만들어 저장할 때 사용하는 `persist()`라는 메소드는 `엔티티 매니저`를 사용해서 객체를 `영속성 컨택스트`에 저장한다
- 엔티티 매니저를 하나 생성할 때 영속성 컨텍스트 하나가 생성된다
- 영속성 컨텍스트는 엔티티를 `식별자 값`으로 구분한다. 따라서 영속 상태는 식별자 값이 **반드시 있어야 한다**
- JPA는 보통 **트랜잭션을 커밋하는 순간** 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 `플러시(flush)`라 한다

### 영속성 컨텍스트의 장점

- 1차 캐시 : 영속성 컨텍스트 내부의 캐시, 영속 상태의 엔티티는 **모두 이곳에 저장**된다. 키는 `@ID`로 매핑한 **식별자**고 값은 **엔티티 인스턴스**이다
    - `find()`메소드 호출시 1. 캐시에서 엔티티를 조회 없을시 2. 데이터 베이스를 조회 한다
    - 데이터베이스에서 조회 시 엔티티 생성 후 **1차 캐시에 저장한 후**에 영속 상태의 **엔티티를 반환**한다
    - 캐시조회로 성능상 이점을 누릴 수 있다
- 1차 캐시에 있는 **같은 엔티티 인스턴스**를 반환함으로 영속 엔티티의 **동일성 보장**한다

### 엔티티 저장

- **쓰기 지연** : 엔티티 매니저는 `트랜잭션`을 커밋하기 직전까지 데이터베이스에 엔티티를 **저장하지 않고** 내부 쿼리 저장소에 `INSERT SQL`을 차곡차곡 모아둔다. 그리고 커밋할 때 데이터베이스에 반영한다.
- **flush() :** `영속성 컨텍스트`의 변경 내용을 데이터베이스에 `동기화`하는 작업이다. 쓰기 지연 SQL 저장소에 모인쿼리를 데이터베이스에 보낸다
- **트랜잭션을 커밋**하지 않으면 데이터베이스에는 저장되지 않는다. 이를 통해 **쓰기지연이 가능한것**이고 한 번에 전달해서 처리하므로 성능을 최적화 할 수 있다

### 엔티티 수정

- **변경 감지** : 엔티티를 영속성 컨텍스트에 보관할 때, **최초 상태를 복사해서 저장**해두는데 이것을 `스냅샷`이라고 한다
    - `플러시` 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다
    - 변경 감지는 영속성 컨텍스트가 관리하는 `영속 상태`의 엔티티만 적용된다
    - 변경 감지된 엔티티는 데이터베이스에서 **모든 필드를 업데이트** 한다.
        - 데이터 전송량이 증가하는 단점이 있지만 **수정 쿼리가 항상 같기 때문에** 어플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 **재사용**할 수 있고**,** 동일한 쿼리를 보낼 시 데이터베이스는 이전에 한 번 파싱된 쿼리를 **재사용**할 수도 있다. (예외로 필드가 많아 내용이 너무 클 시 `DynamicUpdate` 확장 기능 사용시 동적으로 UPDATE 가능하다

### 엔티티 삭제

- 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다. 이후 트랜잭션 커밋시 삭제 쿼리를 전달한다

### 플러시(flush())

- `영속성 컨텍스트`의 변경 내용을 데이터베이스에 **반영(동기화)**한다
    - 변경 감지가 동작하여 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾아 UPDATE SQL을 쓰기 지연 SQL 저장소에 등록한다
    - 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다(등록, 수정, 삭제 쿼리)
- 플러시하는 방법 3가지 :
    - `em.flush()` 직접 호출
    - 트랜잭션 커밋 시 플러시가 자동 호출
    - `JPQL` 쿼리 실행 시 자동 호출
        - 영속 상태의 엔티티들이 DB에 아직 반영이 안되어 있을 수 있기 때문이다

### 엔티티의 생명주기, 영속성상태

![jpa_1](/assets/img/chapter2/jpa/jpa_1.png)

- **비영속 :** 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 엔티티 객체를 생성하고 아직 저장하지 않은 순수한 객체 상태
    - 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다
- **영속(Managed) :** 영속성 컨택스트에 저장된 상태
    - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장하여 관리되는 상태
    - `em.find()` 나 `JPQL`을 사용해서 조회한 엔티티도 **영속** 상태다
- **준영속(Detached) :** 영속성 컨택스트에 저장되었다가 분리된 상태
    - 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다
    - 영속성 컨텍스트의 관리를 받지 못하므로 영속성 컨텍스트의 기능을 사용할 수 없다
        - 1차 cache
        - Trasnaction 쓰기 지연
        - 변경 감지 및 병합
        - 지연 로딩
- **삭제 :** 삭제된 상태(Removed)
    - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다

### 준영속 상태에서 영속 상태로 변경

- 준영속 상태에서 `persisit()` 를 호출하면 **`PersistenceException`**이 발생한다
- 그 이유는 준영속 상태는 식별자를 보유하고 있기 때문에 `persist()`내부에서 id가 없어야 비영속으로 판단하지만 그렇지 않아 준영속이라고 판단해 오류가 발생한다
- **해결방안**
    - `merge()`를 호출해 준영속 엔티티를 영속 상태로 변경해야한다

## 연관관계

- **방향** : 방향은 **객체관계**에서만 존재하고 테이블 관계는 항상 **양방향**이다
- **다중성** : 다대일, 일대다, 일대일, 다대다 등등 다중성이 있다
- **연관관계의 주인** : 객체를 양뱡향 연관관계로 만들면 연관관계의 **주인을 정해야한다**

### 단방향 연관관계

- `참조`를 통한 연관관계는 **언제나 단방향**이다. 객체간에 연관관계를 양뱡향으로 만드려면 연관관계를 하나 더 만들어야 한다. 그럼 **서로 다른 단방향 관계**가 2개가 생긴다(양방향 관계)
- 객체는 **참조**로 연관관계를 맺는다
- 테이블은 **외래 키**로 연관관계를 맺는다
- **`객체 그래프 탐색` :** 객체가 참조를 통해서 연관관계를 탐색할 수 있는 형태를 말한다

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다

### 조회

- 연관관계가 있는 엔티티를 조회하는 방법
    - 객체 그래프 탐색 ex) member.getTeam()을 사용해서 member에 연관된 team 엔티티를 조회할 수 있다
    - 객체지향 쿼리 사용(JPQL)

### 수정

- 단순히 불러온 엔티티 값만 변경해두면 `트랜잭션` 을 커밋할 때 `플러시`가 일어나면서 **변경 감지 기능**이 작동한다
- 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 **먼저 제거**하고 삭제 해야한다

### 양뱡향 연관관계

- 일대다 관계는 여러 건과 연관관계를 맺을 수 있으므로 `컬렉션`을 사용해야 한다(JPA는 List, Collection, Set, Map 같은 다양한 컬렉션을 **지원**한다)
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 `외래 키`를 관리할 수 있다. 주인이 아닌 쪽은 *읽기만 할 수 있다*
- `@mappedBy` 속성을 사용하여 주인이 아님을 설정한다. 그리고 사용되는 값으로는 연관관계 주인인 **엔티티의 필드**를 지정하면 된다
- 연관관계 주인이 아닌 반대편은 **읽기만 가능**하고 외래 키 *변경은 하지 못한다*
- 연관관계의 주인만이 **외래 키의 값을 변경할 수 있다.**
- **객체 관점**에서 양쪽 방향 모두 값을 입력해주는 것이 가장 안전하다
- 양방향 연관관계에서 주인은 **외래 키의 위치**와 관련해서 정해야지 *비지니스 중요도로 접근하면 안 된다*

### 연관관계의 주인

- 객체는 양뱡향 연관관계라는 것은 **없다.** 다만 **서로 다른 단향뱡 연관관계 2개를** 어플리케이션 로직으로 잘 묶어서 양뱡향인 것처럼 보이게 하는 것이다
- 테이블은 외래키가 한개인데 참조는 2개이므로 차이가 발생한다. 이런 차이로 인해 두 객체 연관관계 중 하나를 정해서 테이블의 **외래키를 관리**하는 것이 **연관관계 주인**이다
- 연관관계의 주인은 외래 키가 있는 곳으로 정해야 한다
- 테이블의 다대일, 일대다 관계에서는 **다 쪽이 항상 외래 키를 갖는다. 다** 쪽인 `@ManyToOne`은 항상 연관관계의 주인이 되므로 `mappedBy`를 설정할 수 없다

## 일대다

### 일대다 단방향 [1:N]

- 일대다 관계에서 외래 키는 항상 다 쪽 테이블에 있다
- 일대다 단방향 관계를 매핑할 때는 `@JoinColum` 을 명시해야한다
- 일대다 단방향의 단점
    - 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다
        - 연관관계 처리를 위한 **UPDATE SQL**을 추가로 실행하는 번거러움이 있다
    - 그러므로 일대다 단방향 보다는 **다대일 양방향**을 권장한다

## 일대일

- 일대일 관계를 양쪽이 서로 하나의 관계만 가진다
- 일대일은 둘 중 어느 곳이나 외래 키를 가질 수 있다
- 일대의 관계에서는 **주 테이블에 외래 키**를 둘 것인지 **대상 테이블에 외래 키**를 둘 것인지 선택해야 한다
    - 주 테이블에 외래 키
        - 외래 키를 **객체 참조와 비슷**하게 사용할 수 있어서 객체 개발자들이 선호
        - 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있다
    - 대상 테이블에 외래 키
        - 일대일에서 **일대다**로 변경할 때 테이블 구조를 그대로 유지할 수 있다
        - 대상 테이블의 단방향 연관관계는 *지원하지 않는다*

## 다대다 [N:M]

- 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다
    - 그래서 보통 **일대다**, **다대일**로 풀어낸 테이블을 사용한다
    - 두 테이블 사이에 연결 테이블을 만들어 풀어낼 수 있다

### 컬렉션

- Collection, List는 엔티티를 추가할 때 중복된 엔티티가 있는지 비교하지 않고 단순히 저장만 하면 된다. 따라서 추가해도 지연 로딩 된 컬렉션을 초기화 하지 않는다
    - 이 인터페이스는 `ArrayList`로 초기화 하면 된다
- Set은 엔티티를 추가할 때 중복된 엔티티가 있는지 비교해야 한다. 따라서 엔티티를 추가할 때 지연 로딩 된 컬렉션을 초기화한다
    - 이 인터페이스는 `HashSet`으로 초기화 하면 된다

**List + @OrderColumn**

List 인터페이스 @OrderColumn를 추가하면 순서가 있는 특수한 컬렉션으로 인식한다. 순서가 있다는 말은 **데이터베이스에 순서 값을 저장해서 조회할 때 사용**한다는 의미이다

하지만 단점이 많이 존재해 실무에서는 직접 순서 값을 데이터베이스에서 관리하는 것이 편리하다

### @OrderBy

데이터베이스 `ORDER BY`절을 사용해서 컬렉션을 정렬한다. 따라서 순서용 컬럼을 매핑하지 않아도 된다. `@OrderBy`의 값은 JPQL의 order by 절처럼 **엔티티의 필드를 대상**으로 한다

```java
@Entitiy
public class Team {
	@Id @GnerateValue
	private Long id;
	private String name;
	
	@OneToMany(mappedBy = "team")
	@OrderBy("username desc, id asc")
	private Set<Member> members = new HashSet<Member>();
```

### @Converter

- 컨버터를 사용하면 엔티티의 데이터를 변환해서 데이터베이스에 저장할 수 있다.
- 예를 들어 데이터베이스에 boolean 값을 넣고 싶지만 데이터베이스 방언에 따라 0 또는 1인 숫자로 저장된다. 컨버터를 사용하면 Y, N 혹은 원하는 값으로 저장할 수 있다

```java
@Entity
class Member{
    @Id @GeneratedValue
    private Integer id;

    @Convert(converter=BooleanToYNConverter.class)
    private boolean useYn;
}

@Converter
class BooleanToYNConverter implements AttributeConverter<Boolean, String>{
    @Override
    public String convertToDatabaseColumn(Boolean attribute){
        return (attribute != null && attribute) ? "Y" : "N";
    }

    @Override
    public Boolean convertToEntityAttribute(String dbData){
        return "Y".eqauls(dbData);
    }
}
```

```java
@Entity
@Converter(converter = BooleanToYNConverter.class, attributeName ="vip")
	classMember{
	private String name;
	private boolean vip;
}

```

**글로벌 설정**

모든 Boolean 타입에 설정하고 싶을 경우 아래와 같이 직접 컨버터에 명시해주면 된다.

```java
@Converter(autoApply = true)
class BooleanToYNConverter implements AttributeConverter<Boolean, String>{
    // ...
}
```

### 엔티티 그래프

- 엔티티를 조회할 때 연관된 엔티티들을 함께 조회하려면 글로벌 옵션을 `FetchType.EAGER` 혹은 JPQL에서 **페치 조인을 사용**하면 된다.
- 하지만 글로벌 fetch 옵션은 어플리케이션 전체에 영향을 줄 수 있기 때문에 **LAZY 옵션을 사용**하고 엔티티를 조회할 때 연관된 엔티티를 함께 조회할 필요가 있으면 **JPQL의 페치 조인을 사용한다**
- 하지만 다양한 메소드에서 여러 조인이 필요한 경우가 필요할 수도 있고 조인이 필요 없을 수도 있다. 그러다 보면 점점 화면에 의존하여 리포지토리가 작성되게 된다. 엔티티 그래프 기능을 사용하면 엔티티를 조회하는 시점에 **함께 조회할 연관된 엔티티를 선택할 수 있다**
- **엔티티 그래프 기능은 엔티티 조회시점에 연관된 엔티티들을 함께 조회하는 기능이다**

```java
// ("select m from Member m left join fetch m.team" 쿼리와 똑같은 결과)
@Override
@EntityGraph(attributePaths = {"team"}) // 옵션 : 연관된 엔티티 지정
List<Member> findAll();
```

**@EntityGraph를 JPQL과 함께 사용하는 방법**

```java
@Query("select m from Member m")
@EntityGraph(attributePaths = {"team"})
List<Member> findMemberEntityGraph();
```

참고 - 자바 ORM 표준 JPA 프로그래밍
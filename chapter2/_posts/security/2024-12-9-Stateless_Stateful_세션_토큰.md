# Stateless, Stateful, 세션, 토큰

## Stateless

- 클라이언트-서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미한다
- Stateless 구조에서 `Server`는 단순히 요청이 오면 응답을 보내는 역할만 수행하며, 세션 관리는 클라이트에게 책임이 있다
- 웹서버 통신(http) 특성상 사용자(브라우저)의 이전 상태 client(쿠키) or server(세션) 정보를 기록하지 않는 접속이란 의미다
- **브라우저가 데이터를 전송할 때마다 연결하고 바로 끊어버리는 방식**이다.
    - **장점** : 서버의 확장성이 높기 때문에 **대량의 트래픽 발생 시에도 대처를 수월**하게 할 수 있다.
    - **단점** : 클라이언트의 요청에 상대적으로 **Stateful 보다 더 많은 데이터가 소모**된다. (*매번 요청할때마다 자신의 부가정보를 줘야 한다*)
    - ex) HTTP, UDP, DNS

## Stateful

- 클라이언트-서버 관계에서 서버가 **클라이언트의 상태를 보존**함을 의미한다
- 클라이언트의 이전 요청이 서버에 잘 전달되었을 때, 클라이언트의 다음 요청이 이전 요청과 관계가 이어지는 것을 의미한다
    - 상태에 대해 저장해야하기 때문에 백업 스토리지가 요구된다.
    - 상태 저장에 대한 요청은 서버 측 상태에 따라 달라지게 된다.
    - **서버가 클라이언트의 세션 정보를 저장한다**
    - ex) TCP, FTP, Telnet

**Stateless 한 프로토콜 : HTTP**

- HTTP 통신신은 `stateless` 한 특성 때문에 각 통신의 상태는 저장되지 않는다
- 하지만 서비스에서는 어떤 유저가 기능을 사용하는지 특정할 수 있어야하는데 이를 위해서 `세션` 혹은 `토큰`이 사용된다
- 토큰은 클라이언트 측에서만 저장되지만 세션은 데이터베이스 서버에 저장된다

## Session + Cookie

- 쿠키에 ID, PW 같은 중요한 정보가 아닌, 인증을 위한 별개의 정보를 **세션 저장소에 저장**하고, **클라이언트는 세션을 쿠키에 담아 서버에 요청**한다. 서버는 세션 저장소에 있는 세션과 일치하는지, 즉 유효한 세션인지 확인 후 적절한 응답을 보내준다

### 문제점

- `세션 ID`, `Cookie` 등이 탈취된다면 세션 저장소를 전부 지워 해결 가능하지만, 탈취 당하지 않는 정상적인 사용자도 모두 재인증을 해야하는 상황이 발생한다
- HTTP의 가장 큰 특성 중 하나인 `stateless` 특성을 위배한다

## 토큰, JWT

- `JWT 토큰` 방식은 웹표준(RFC 7519)로서 두 개체에서 **JSON 객체**를 사용하여 가볍고 자가수용적인 방식으로 정보를 안정성 있게 전달한다

### JWT의 구조

![jwt_1.png](/assets/img/chapter2/jwt/jwt_1.png)

### 헤더 (Header)

헤더는 두 가지 정보를 가진다

- typ - 토큰의 타입(JWT)
- alg - 해싱 알고리즘
    - Signature 를 해싱하기 위한 알고리즘 지정

### 내용 (payload)

Payload에는 토큰에 담을 정보들이 존재하고, 여기에 담는 정보의 한 조각을 `클레임`(claim)이라고 한다

- 클레임은 키 값 형태로 존재한다
- 클레임은 3가지 종류로 나뉜다
- **등록된 클레임(registered claims)**
    - 등록된 클레임들은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임들이다
        - iss: 토큰 발급자 (issuer)
        - sub: 토큰 제목 (subject)
        - aud: 토큰 대상자 (audience)
        - exp: 토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정
        - nbf: Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념이다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않는다
        - iat: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있다
        - jti: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용하다
- **공개 클레임(pulibc claims)**
    - 사용자 마음대로 쓸 수 있으나 충돌 방지를 위해 정의된 대로 사용하는 게 좋다
- 비공개 클레임(private claims)
    - 통신을 주고받는 당사들끼리 협의해서 자유롭게 키와 값을 정할 수 있다

### 장점

- 인증에 필요한 정보가 토큰에 있기에 **별도의 저장소가 필요 없다**
    - 하지만, 보안성을 높이기 위해 `Refresh Token` 은 별도의 저장소에 저장한다
- `Cookie`와 `Session` 사용 시 문제점이였던 `stateful` 한 특성을 `JWT 토큰` 사용 시에는 `stateless` 하게 가져갈 수 있다. 즉, 서버는 클라이언트의 상태를 가질 필요가 없다.
- **CSRF 방지**
    - 사용자가 사이트를 벗어나도 이미 쿠키가 사용자 정보를 가지고 있기 때문에 공격에 노출 될 위험이 있다
        - 공격자가 임의로 다른 URL로 유도하여 악성 공격을 할 수 있다
        - **토큰 기반 인증에서는 헤더 내 토큰이 포함되어 CSRF를 방지한다**
- 확장성에 용이하다. `MSA` 환경에 적용하기 편하다
    - 여러개의 서버에서 한 세션이 첫 번째 서버에 생성되면, 새로운 요청이 발생하고 그 요청이 다른 서버에 전달되면 세션 정보가 없어 처리가 불가능하다
    - **토큰 기반 요청은 요청에 토큰을 넣고 서버가 가로채기 때문에** 자연스럽게 문제가 해결 된다

### 단점

- 거의 모든 요청에 토큰이 포함되므로 **트래픽 크기에 영향**을 미친다
- 토큰에 정보가 많아져 토큰의 크기가 커지면 **네트워크 부하를 줄 수 있다**
- 따라서 페이로드에 중요 정볼르 담아선 안된다
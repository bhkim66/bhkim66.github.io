# MSA 패턴
### 이벤트 기반 아키텍처

분산된 어플리케이션 서비스들이 **이벤트를 기반으로 통신하고 서로 함께 작동**하는 아키텍처이다

### 이벤트

`이벤트`는 상태(예: `상품 가격`, `배송 주소`)를 전달할 수 있으며, 또는 이벤트가 식별자(예: `주문 접수`, `배송 알림`)일 수 있다

![msa_1_1](/assets/img/chpater2/msa/msa_1_1.png)

- `이벤트 라우터`는 여러 서비스를 연결하며 메세지를 주고 받는 매체이다.
- `이벤트 제작자`가 생성한 원래 이벤트에 대한 응답을 실행하고 이 응답을 다운스트림으로 적절한 `소비자`에게 전송한다

![msa_1_2](/assets/img/chpater2/msa/msa_1_2.png)

**장점**

- **느슨한 결합 및 개발자 민청성 향상**
    - 이벤트 제작자는 이벤트 소비자로부터 논리적으로 구분된다. 이벤트 생성과 소비 간에 분리된 방식으로 작동하므로 서비스는 상호 운용 가능하지만 서로 독립적으로 `확장`, `업데이트`, `배포`할 수 있다
    - 느슨한 결합은 종속 항목을 줄이고 다양한 언어와 프레임워크로 서비스를 구현할 수 있도록 한다
- **비동기 이벤트 및 복원력**
    - 이벤트 기반 시스템에서는 이벤트가 `비동기식`으로 생성되며 응답을 기다리지 않고 즉시 발생할 수 있다. 느슨하게 결합된 구성요소는 **한 서비스가 실패해도 다른 서비스가 영향을 받지 않고 서비스는 그대로 진행된다**
    - `동기` 처리와 `비동기` 처리
        - `동기 방식`은 요청자와 제공자 사이에서 계속 `Connection`이 맺어져 있어야 하고, `비동기 방식`은 `Connection`은 끊어지고 서로간에 `이벤트`를 통해 통신하는 방식이다
        - `비동기 방식`은 요청자와 제공자 사이에 `Message Broker`라는 또 다른 서비스가 중계해주지만, 동기 방식은 요청자 어플리케이션에 `non-blocking`처리를 하는 로직이 있다
        - `Non-blocking`
            - 요청하고 다른 작업 후 응답신호가 오면 결과를 읽어 처리하는 방식
        - `blocking`
            - 요청하고 응답 올 때 까지 기다리는 방식
        - **Frontend와 backend사이는 거의 대부분 동기+non-blocking 방식**으로 구현한다
- **푸시 기반 메세징, 실시간 이벤트 스트림, 저렴한 비용**
    - 이벤트 기반 시스템을 사용하면 **푸시 기반 메시지를 사용할 수 있으며** 클라이언트는 원격 서비스를 지속적으로 `폴링`하여 **상태 변경을 확인하지 않고도 업데이트를 받을 수 있다**
- **간소화된 감사 및 이벤트 소싱**
    - 이벤트 라우터의 중앙 집중식 위치를 통해 감사를 간소화하고, 라우터와 상호작용할 수 있는 사용자, 데이터에 액세스할 수 있는 사용자 및 리소스를 제어할 수 있다

## MSA (Micro Service Architecture)

`MSA`는 하나의 큰 어플리케이션을 **여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처**이다

### **모놀리식 아키텍처 (Monolithic Architecture)**

`모놀리식 아키텍처`는 어플리케이션의 모든 구성 요소가 단일 단위 내에 배치되는 아키텍처이다

- 이 단위는 일반적으로 **어플리케이션의 단일 런타임 인스턴스 이내로 제한**된다
- 대체로 웹 인터페이스, 서비스 계층, 데이터 계층으로 구성된다
- 모놀리식 아키텍처는 이러한 계층이 어플리케이션의 인스턴스에서 결합된다

모놀리식 아키텍처는 대체로 작은 애플리케이션에는 적합한 솔루션이지만 애플리케이션이 커짐에 따라 제어하기 어려워질 수 있다. 원래는 작았던 애플리케이션이 특정 서비스의 `Scale-out`, `배포`, `수정`이 어려운 복잡한 시스템이 되며 **부분의 장애가 전체 서비스의 장애로 이어질 수 있다**

**이 문제점의 대안으로 `MSA`패턴이 등장했다**

![msa_1_3](/assets/img/chpater2/msa/msa_1_3.png)

- `MSA`는 작고 **독립적이며 느슨하게 결합되어 있다 (**`비동기 방식`**)**
- 각 서비스는 작은 개발 팀이 관리할 수 있는 개별 코드 베이스이다
- 서비스를 **독립적으로 배포할 수 있다**

서비스 자체 외에도 다음과 같은 몇 가지 다른 구성 요소가 기존 마이크로 서비스 아키텍처에 나타난다

- **오케스트레이션**
    - 이 구성 요소는 노드에 `서비스 배치`, `실패 식별`, `노드 간에 서비스 부하 조정` 등의 작업을 담당한다. 일반적으로 이 구성 요소는 사용자 지정 빌드가 아니라 Kubernetes와 같은 기성 기술이다
- **API 게이트웨이**
    - 클라이언트의 진입점이다. **클라이언트는 서비스를 직접 호출하는 대신, 호출을 백 엔드의 적잘한 서비스에 전달**하는 `API 게이트웨이`를 호출한다

## Saga 패턴

마이크로서비스는 **서비스마다 고유 DB를 가지고 있다**. 이 분산된 DB간 정합성을 보장해야한다.

`Saga` 디자인 패턴은 분산 트랜잭션 시나리오에서 마이크로 서비스 간의 **데이터 일관성을 관리하는 방법**이다. `Saga`는 각 서비스를 업데이트하고 메시지 또는 이벤트를 게시하여 **다음 트랜잭션 단계를 트리거하는** 일련의 `트랜잭션`이다.

> `트랜잭션`이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위
>

![msa_1_4](/assets/img/chpater2/msa/msa_1_4.png)

- Saga 패턴은 일련의 **로컬 트랜잭션을 사용**하여 트랜잭션 관리를 제공한다
- 로컬 트랜잭션은 Saga에 속한 `Service`가 수행하는 **원자성 작업**이다
- 각 로컬 트랜잭션은 **데이터베이스를 업데이트**하고 **메시지** 또는 **이벤트**를 게시하여 `Saga`에서 다음 로컬 트랜잭션을 트리거한다
- 로컬 트랜잭션이 실패하면 `Saga`는 이전 로컬 트랜잭션에 의해 변경된 내용을 실행 취소하는 *일련의 **보상* 트랜잭션**(Rollback)**을 실행한다**

![msa_1_5](/assets/img/chpater2/msa/msa_1_5.png)

**Saga 패턴의 방식**

### **Choreography based SAGA pattern**

![msa_1_6](/assets/img/chpater2/msa/msa_1_6.png)

- **Choreography based SAGA pattern**은 보유한 서비스 내의 `Local 트랜잭션`을 관리하며 트랜잭션이 종료하게 되면 완료 Event을 발행한다. 만약 그 다음 수행해야 할 트랜잭션이 있으면 해당 트랜잭션을 수행하는 어플리케이션으로 이벤트를 보내고 작업을 진행한다
- Event은 `Kafka`와 같은 메세지 브로커가 필요하다
- **도메인간 종속성이 낮아진다**
- *트랜잭션의 현재 상황을 확인하기 어렵다*

### **Orchestration based SAGA pattern**

![msa_1_7](/assets/img/chpater2/msa/msa_1_7.png)

- 오케스트레이션은 중앙 집중식 컨트롤러가 Saga 서비스에게 실행할 로컬 트랜잭션을 알려준다
- 트랜잭션에 관여하는 모든 App은 `Manager`에 의해 **점진적으로 트랜잭션을 수행**하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 `Manager`를 종료해서 전체 트랜잭션 처리를 종료
- 중간에 실패시 `Manager`에서 보상 트랜잭션을 발동한다
- **새로운 서비스 추가가 많을 시 적합하다**
- **모든 흐름을 제어할 수 있다**
- **오케스트레이터는 일방적으로 각 서비스에 의존하기 때문에 순환 종속성을 도입하지 않는다**
- *관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해진다*

참조

https://learn.microsoft.com/ko-kr/azure/architecture/microservices/design/patterns

https://learn.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/microservices

https://cloud.google.com/eventarc/docs/event-driven-architectures?hl=ko

https://learn.microsoft.com/ko-kr/azure/architecture/reference-architectures/saga/saga#choreography